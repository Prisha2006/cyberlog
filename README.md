
Cyberlog is my first Flutter project where I learned the fundamentals of cross-platform mobile development. In this project, I explored the difference between native and cross-platform apps, understood how Flutter uses a single codebase for Android and iOS, and learned how Hot Reload helps speed up UI development. I also studied Flutter’s widget system, including stateless and stateful widgets, which form the core structure of every Flutter UI.

To run the app, I installed the Flutter SDK, used flutter doctor to verify my setup, created the project using flutter create cyberlog, and launched it on an emulator and physical device using flutter run. The project includes screenshots of the working application and a basic folder structure generated by Flutter.

Overall, Cyberlog represents the successful setup and execution of my first professional Flutter project.
<img width="540" height="1200" alt="image" src="https://github.com/user-attachments/assets/f9605e60-c9dd-4f85-b242-d2bd9926e731" />

#session 2#
JIT vs AOT Compilation
JIT (Just-In-Time Compilation)
Code is compiled while the app is running.
Used during Flutter development (Hot Reload & Hot Restart).
Makes development fast because changes update instantly.
Slightly slower performance compared to AOT.

AOT (Ahead-Of-Time Compilation)
Code is compiled before execution into optimized machine code.
Used when building release APK/IPA.
Provides faster startup, better performance, and smaller runtime overhead.
Not used during development because it takes more time to compile.

How Dart Conditionals Were Used in the Even/Odd Checker
The % operator returns the remainder.
If the remainder is 0, the number is even.
Otherwise, it is odd.
The result is stored in a String variable and displayed in the UI.

How String Interpolation Was Used
The variable number is directly placed inside the string using $number.
This makes the output message readable and easy to update without manual string concatenation.
String interpolation improves clarity and reduces errors.

#session3#
How Classes Were Used
A custom Log class was created to structure log entries:
class Log {
  String action;
  DateTime timestamp;
  String status;
  Log(this.action, this.timestamp, this.status);
}
This allows each log to be treated as a real object with clearly defined properties instead of loose variables.
Classes help organize data cleanly and make the project easier to extend later.

How Lists & Iteration Were Used to Render UI
A list of Log objects was created:
List<Log> logs = [ Log(...), Log(...), Log(...) ];
To display each log entry on the screen, the .map() function was used:
children: logs.map((log) {
  return Text("${log.action} — ${formattedTime}");
}).toList(),

Using .map() is efficient because:
No manual looping widget-by-widget
Clean, readable code
Easy to add or remove items
Converts each Log into a UI element automatically
This is a standard Flutter approach for rendering repeating data.

#session 5#
<img width="540" height="1200" alt="image" src="https://github.com/user-attachments/assets/a254b661-a5b1-4427-ad78-777d41fd65a9" />


